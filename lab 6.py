# -*- coding: utf-8 -*-
"""Lab_6.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1f_xafmJHR6zCScq5KpwHkY2iVJ-GjBnl

Задание 1:
1. Создайте Series из последовательности 15 значений, равномерно разбивающих отрезок [0,
20] (воспользуйтесь функцией linspace)
2. Определите отношение элементов полученной серии к их предыдущим элементам (*).
3. В результате необходимо получить среднее полученного вектора, оставив в нём только те
значения, которые не более чем 1.5 (**).
"""

import pandas as pd
import numpy as np

series = pd.Series(np.linspace(0, 20, num=15))
print(f'Series из 15 значений:\n{series}')

ratio = series / series.shift(1)
print(f'\nОтношение:\n{ratio}')

mean = np.mean(ratio[ratio <= 1.5])
print(f'\nCреднее полученного вектора:\n{mean}')

"""Задание 2:
Выберите все верные ответы касательно следующих четырех Series:
- pd.Series('abcde'); (1)
- pd.Series(['abcde']); (2)
- pd.Series(list('abcde')); (3)
- pd.Series("abcde"); (4)
Вопросы:
1) Серия (1) совпадает с серией (2), так как в каждом из случаев серия создаётся и
з списка строк
2) Серия (2) совпадает с серией (3), так как в каждом из случаев серия создаётся и
з списка символов
3) Серия (1) не совпадает с серией (4), так как в (4) используются двойные кавычк
и "" вместо одинарных ''

Овет: 1
"""

pd.Series('abcde')
print(pd.Series('abcde'))
pd.Series(['abcde'])
print(pd.Series(['abcde']))
pd.Series(list('abcde'))
print(pd.Series(list('abcde')))
pd.Series("abcde")
pd.Series(pd.Series("abcde"))

"""Задание 3:

Для заданного ниже объекта s проделайте следующее:
1. Создайте новый Series, значения которого совпадают со значениями s, а индексы -
целочисленные значения от 2 до 12, не включая 12.
2. Выберите из s элементы с индексами 3 и 5, после чего просуммируйте их, сохранив
результат (1).
3. Выберите из s только целочисленные элементы и вычислите их дисперсию (2). (*)
s = pd.Series(data=['1', 2, 3.1, 'hi!', 5, -512, 12.42, 'sber', 10.10, 98],
 index=range(6, 26, 2))
"""

series = pd.Series(data=['1', 2, 3.1, 'hi!', 5, -512, 12.42, 'sber', 10.10, 98], index=range(6, 26, 2))

series2 = pd.Series(series.values, index=range(2, 12))
print(f'Новый series с индексами 2 - 12:\n{series2}')

#print(f'\nСумма элементов с индексами 3 и 5: {float(series[3]) + float(series[5])}')

a = series[series.apply(lambda x: isinstance(x, int))]
print(f'Дисперсия:\n{a.var()}')

"""Задание 4:
1. Сгенерируйте Series из 100 значений нормально распределённой СВ
(np.random.normal с дефолтными параметрами - нулевым средним и единичной
дисперсией).
2. Возведите каждое значение серии в 3 степень, а значения индекса увеличьте в 3
раза.
3. Ответьте на следующие вопросы
 1) Выведите сумму элементов, строго меньших 2.6, имеющих нечётные
значения индекса.
 2) Выведите количество значений серии меньше нуля.
Для того, чтобы результаты были воспроизводимы, используйте np.random.seed(242)
"""

np.random.seed(242)

series = pd.Series(np.random.normal(size=100)**3, index = [x*3 for x in range(100)])
print(f'Series:\n{series}')

print(f'\nСумма: {series[(series.index % 2 != 0) & (series < 2.6 )].sum()}')

print(f'\nКоличество значений меньше 0: {series[series<0].count()}')

"""Задание 5:

"""

data = pd.read_table("wr88125.txt", sep = ";", na_values='     ', header=None)

data.columns = ["index", "year", "month", "day", "min_t", "average_t", "max_t", "rainfall"]

data.drop('index', axis=1, inplace=True)
print(f'Таблица после удаление index:\n{data}')

print(f'{data.info()}')

max_year = data.isnull().groupby(data['year']).sum().sum(axis=1).idxmax()
print(f'\nГод с наибольшим количеством пропусков: {max_year}')

data['date'] = pd.to_datetime(data[['year', 'month', 'day']])
data.drop(['year', 'month', 'day'], axis=1, inplace=True)

print(f'Таблица после объединение год, месяц, день:\n{data}\n')

data['RangeOfTemp'] = 0
data['DaysWithoutRain'] = 0

for i in range(len(data)):
    min_t = data.loc[i, 'min_t']
    max_t = data.loc[i, 'max_t']
    temp_range = max_t - min_t
    data.loc[i, 'RangeOfTemp'] = temp_range

NoRain = 0
for i in range(len(data)):
    data.loc[i, 'DaysWithoutRain'] = NoRain
    rainfall = data.loc[i, 'rainfall']
    if rainfall == 0.0: NoRain += 1
    else: NoRain = 0

print(f'Таблица после вычисление размаха температур и дней засухи:\n{data}\n')

MaxNoRain = data['DaysWithoutRain'].max()
print(f'\nСамый длинный период засухи: {MaxNoRain}')

AVGtemp = data.groupby(pd.DatetimeIndex(data['date']).year)['average_t'].mean()
AVGrain = data.groupby(pd.DatetimeIndex(data['date']).year)['rainfall'].sum()

Warm = AVGtemp.idxmax()
print(f'\nСамый тёплый год: {Warm}\n')
Cold = AVGtemp.idxmin()
print(f'Самый холодный год: {Cold}\n')

MoreRain = AVGrain.idxmax()
print(f'Год с наибольшим количеством осадков: {MoreRain}')
LowRain = AVGrain.idxmin()
print(f'Год с наименьшим количеством осадков: {LowRain}')

filter = data[data['average_t'] < -30]
print(f'\nНаблюдения с средней температурой ниже -30:\n{filter}')

filter2 = data[(data['average_t'] > 27) & (data['DaysWithoutRain'] > 3)]
print(f'\nНаблюдения с средней температурой выше 27 и количеством дней без осадков больше 3:\n{filter2}')